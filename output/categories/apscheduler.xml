<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/" version="2.0"><channel><title>Jason Wu's Thoughts and Writings (文章分类：apscheduler)</title><link>https://vimer.im/</link><description></description><atom:link type="application/rss+xml" rel="self" href="https://vimer.im/categories/apscheduler.xml"></atom:link><language>zh_cn</language><copyright>Contents © 2018 &lt;a href="mailto:jasonwux@gmail.com"&gt;JasonWu&lt;/a&gt; </copyright><lastBuildDate>Sun, 11 Mar 2018 03:11:48 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>解决django使用多进程部署时apscheduler重复运行的问题</title><link>https://vimer.im/posts/Solving-the-problem-of-APScheduler-duplication-in-multi-process/</link><dc:creator>JasonWu</dc:creator><description>&lt;div&gt;&lt;div class="section" id="id1"&gt;
&lt;h2&gt;问题&lt;/h2&gt;
&lt;p&gt;在一个django应用中需要定时执行一些任务，所以用了APScheduler这个库。在开发中直接测试运行是没有问题的，但是用gunicorn部署以后发生了重复运行的问题：每个任务在时间到的时刻会同时执行好几遍。注意了一下重复的数量，恰恰是gunicorn里配置的worker进程数量，显然是每个worker进程都启动了一份scheduler造成。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;解决&lt;/h2&gt;
&lt;p&gt;可以想到的方案有几个：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;用--preload启动gunicorn，确保scheduler只在loader的时候创建一次&lt;/li&gt;
&lt;li&gt;另外创建一个单独的定时任务项目，单独以一个进程运行&lt;/li&gt;
&lt;li&gt;用全局锁确保scheduler只运行一次&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;经过实践，只有第三个方案比较好。&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;preload的问题：&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
虽然这样可以使用scheduler创建代码只执行一次，但是问题也在于它只执行一次，重新部署以后如果用kill -HUP重启gunicorn，它并不会重启，甚至整个项目都不会更新。这是preload的副作用，除非重写部署脚本，完全重启应用。&lt;/blockquote&gt;
&lt;ol class="arabic simple" start="2"&gt;
&lt;li&gt;单独进程的问题：&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
也是因为部署麻烦，需要多一套部署方案，虽然用Docker会比较方便，但仍然不喜欢，而且同时维护两个项目也多出很多不必要的事情。&lt;/blockquote&gt;
&lt;ol class="arabic simple" start="3"&gt;
&lt;li&gt;全局锁是一个较好的方案，但问题在于找一个合适的锁。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
python自带的多进程多线程锁方案都需要一个共享变量来维护，但是因为worker进程是被gunicorn的主进程启动的，并不方便自己维护，所以需要一个系统级的锁。在Stackoverflow上看到有人是用了一个socket端口来做锁实现这个方案，但是我也不喜欢这样浪费一个宝贵的端口资源。不过这倒给了我一个启发，可以用文件锁，于是有了这个解决方案：&lt;/blockquote&gt;
&lt;pre class="code python"&gt;&lt;a name="rest_code_5903de726fc74f2daeba9cdfc30975b9-1"&gt;&lt;/a&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;atexit&lt;/span&gt;
&lt;a name="rest_code_5903de726fc74f2daeba9cdfc30975b9-2"&gt;&lt;/a&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;fcntl&lt;/span&gt;
&lt;a name="rest_code_5903de726fc74f2daeba9cdfc30975b9-3"&gt;&lt;/a&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;apscheduler.scheduler&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Scheduler&lt;/span&gt;
&lt;a name="rest_code_5903de726fc74f2daeba9cdfc30975b9-4"&gt;&lt;/a&gt;
&lt;a name="rest_code_5903de726fc74f2daeba9cdfc30975b9-5"&gt;&lt;/a&gt;&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"scheduler.lock"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"wb"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a name="rest_code_5903de726fc74f2daeba9cdfc30975b9-6"&gt;&lt;/a&gt;&lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a name="rest_code_5903de726fc74f2daeba9cdfc30975b9-7"&gt;&lt;/a&gt;    &lt;span class="n"&gt;fcntl&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;flock&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fcntl&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;LOCK_EX&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;fcntl&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;LOCK_NB&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a name="rest_code_5903de726fc74f2daeba9cdfc30975b9-8"&gt;&lt;/a&gt;&lt;span class="k"&gt;except&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a name="rest_code_5903de726fc74f2daeba9cdfc30975b9-9"&gt;&lt;/a&gt;    &lt;span class="k"&gt;pass&lt;/span&gt;
&lt;a name="rest_code_5903de726fc74f2daeba9cdfc30975b9-10"&gt;&lt;/a&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a name="rest_code_5903de726fc74f2daeba9cdfc30975b9-11"&gt;&lt;/a&gt;    &lt;span class="n"&gt;sched&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Scheduler&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;a name="rest_code_5903de726fc74f2daeba9cdfc30975b9-12"&gt;&lt;/a&gt;
&lt;a name="rest_code_5903de726fc74f2daeba9cdfc30975b9-13"&gt;&lt;/a&gt;    &lt;span class="nd"&gt;@sched.interval_schedule&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;seconds&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;60&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a name="rest_code_5903de726fc74f2daeba9cdfc30975b9-14"&gt;&lt;/a&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;mytask&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
&lt;a name="rest_code_5903de726fc74f2daeba9cdfc30975b9-15"&gt;&lt;/a&gt;    &lt;span class="sd"&gt;'''&lt;/span&gt;
&lt;a name="rest_code_5903de726fc74f2daeba9cdfc30975b9-16"&gt;&lt;/a&gt;&lt;span class="sd"&gt;    定义你的定时任务执行的内容&lt;/span&gt;
&lt;a name="rest_code_5903de726fc74f2daeba9cdfc30975b9-17"&gt;&lt;/a&gt;&lt;span class="sd"&gt;    '''&lt;/span&gt;
&lt;a name="rest_code_5903de726fc74f2daeba9cdfc30975b9-18"&gt;&lt;/a&gt;        &lt;span class="k"&gt;pass&lt;/span&gt;
&lt;a name="rest_code_5903de726fc74f2daeba9cdfc30975b9-19"&gt;&lt;/a&gt;
&lt;a name="rest_code_5903de726fc74f2daeba9cdfc30975b9-20"&gt;&lt;/a&gt;    &lt;span class="n"&gt;sched&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;a name="rest_code_5903de726fc74f2daeba9cdfc30975b9-21"&gt;&lt;/a&gt;
&lt;a name="rest_code_5903de726fc74f2daeba9cdfc30975b9-22"&gt;&lt;/a&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;unlock&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
&lt;a name="rest_code_5903de726fc74f2daeba9cdfc30975b9-23"&gt;&lt;/a&gt;    &lt;span class="n"&gt;fcntl&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;flock&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fcntl&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;LOCK_UN&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a name="rest_code_5903de726fc74f2daeba9cdfc30975b9-24"&gt;&lt;/a&gt;    &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;a name="rest_code_5903de726fc74f2daeba9cdfc30975b9-25"&gt;&lt;/a&gt;
&lt;a name="rest_code_5903de726fc74f2daeba9cdfc30975b9-26"&gt;&lt;/a&gt;&lt;span class="n"&gt;atexit&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;register&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;unlock&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;原理&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;首先打开（或创建）一个scheduler.lock文件，并加上非阻塞互斥锁。成功后创建scheduler并启动。&lt;/p&gt;
&lt;p&gt;如果加文件锁失败，说明scheduler已经创建，就略过创建scheduler的部分。&lt;/p&gt;
&lt;p&gt;最后注册一个退出事件，如果这个django退出，则解锁并关闭scheduler.lock文件的锁。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;&lt;/div&gt;</description><category>apscheduler</category><category>django</category><guid>https://vimer.im/posts/Solving-the-problem-of-APScheduler-duplication-in-multi-process/</guid><pubDate>Sun, 11 Mar 2018 02:45:42 GMT</pubDate></item></channel></rss>